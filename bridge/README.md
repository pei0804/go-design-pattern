# 概要

橋渡しという意味そのままです。橋渡しするものは、「昨日のクラス階層」と「実装のクラス階層」です。

## クラス階層の2つの役割

### 新しい機能を追加したい時(機能のクラス階層)

Aクラスというものがあったとします。もし、Aクラスに新しい昨日を追加したいと思った時、Aクラスのサブクラスとして、A_Childクラスを作ります。これで階層が出来ました。

```
A > A_child
```

これは機能追加のために作られた階層です。

- スーパークラスは基本的な機能を持っている
- サブクラスで新しい機能を追加する

上記のようなことを、「機能のクラス階層」と呼ぶことにします。

もし、A_Childにさらに何か追加したいとかになると、さらに階層が増えます。（あまり深くなりすぎるのはよくないです）

### 新しい「実装」を追加したい時(実装のクラス階層)

Template Methodなどで、抽象的なメソッドを宣言して、サブクラスで具体的な振る舞いを書くということをしました。ここにも、クラス階層が登場します。

A_interface > A_interface_method

でも、ここで使われるクラス階層は、機能を追加するためではありません。

- スーパークラスは抽象メソッドによってインターフェイスを規定している
- サブクラスは具象メソッドによってそのインターフェイスを実装する

このようなクラス階層を、「実装のクラス階層」と呼ぶことにします。

先程の機能クラス階層とは違い。こちらはどんどん増えても並行に並んでいきます。

```
A_interface > A_interface_method
            > A_interface_method
```

# 分けておけば、拡張が楽になる

Bridgeの特徴は機能のクラス階層と実装のクラス階層を分けている点にある。この2つのクラス階層を分けておけば、それぞれのクラス階層を独立に拡張することが出来る。

機能を追加したければ、機能のクラス階層にクラスを追加する。この場合、実装のクラス階層は全く修正が必要ない。しかも、いま追加した機能は全ての実装で利用可能です。

# 継承は固い結びつき、委譲はゆるやかな結びつき

継承は、クラスを拡張するためには便利な方法ですが、クラス間の結びつきをがっちりと固定してしまう。
この関係性を一度作ってしまうと、ソースコードの書き換えをしない限り、変えることが出来ません。必要に応じてクラスの関係を切り替えたい時は、継承を使うべきでありません。こういう場合は継承ではなく委譲を使います。

Displayは移譲が使われています。Displayにはimplフィールドがあり、実際の動作はimplに全て移譲しています。この動作が決定するのは、Displayのインスタンスを作る段階で、引数に結びつくことになっています。なので、StringDisplayImplと違うConeerateImplementorがいたなら、DisplayやCountDisplayに渡すものを変えるだけで、動作を切り替えることができ、DispayやDisplayImplは全く変える必要がありません。これが委譲のゆるやかな結びつきです。
